# Тестовое задание от компании Drivee

## Стек технологий

Backend: `golang, postgresql`
Frontend: `vite, react, TypeScript`

## Задача

Написать алгоритм распределения заказов между курьерами, чтобы был приоритет в скорости доставки посылки клиентам.

## Решение

Данная задача очень похожа на задачу коммивояжера, только с тем условием, что нет конкретной точки, а есть вектор с направленнием. Я решил, что эта задача является задачей коммивояжера, а именно мультиагентной асимметричной задачей коммивояжера с заданным началом, поэтому мое решение будет исходить из такого суждения.

Обычно мультиагентную задачу коммивояжера решают с помощью кластеризации агентов и одним из многих алгоритмов решения задачи коммивояжера.

Для решения данной проблемы я выбрал алгоритм [Хельда-Капра](https://life-prog.ru/2_72037_rassmotrim-algoritm-helda-i-karpa.html) для нахождения кратчайшего пути между заказами одного курьера, но для распределения курьеров будем использовать кластеризацию по ближайшим заказам к курьеру.

Значение будем брать исходя из расстояния между точками (координаты), приблизительная скорость курьера. Можно взять также такие параметры, как рейтинг курьера, чп, пробки, погодные условия, но я думаю, что не успею выполнить это всё в срок, поэтому пренебрегу такими параметрами.

### Объяснение кода

Задача коммивояжера или Travel salesman problem (TSP)
в основном предполагает решение симметричного характера,
где первоначальная точка входа является и конечной.
Для данной задачи это не подходит, поэтому нужно создать
фиктивную точку, которая будет являться входом в точку
курьера. Есть одна проблема, без "стенок" такая реализация
не работает с определенной начальной точкой, поэтому
нужно для этого задать точку входа и точку выхода, так
чтобы алгоритм всегда выбирал их.

Я нашел подобное решение, но оно мне не нравится, но из-за
отсутствия в моей голове альтернатив буду использовать
именно это решение.

Решение звучит так. Увеличим матрицу на 1, (К примеру, 3x3 на 4x4)
добавим числа намного большие, чем все остальные в первый ряд, а
также и во второй ряд. Определим входную точку по индексу 1 (Курьер)
поставим там 0, а также определим выходную точку по индексу (от 2 до n)
поставим там также 0. Получается алгоритм будет входить из фиктивной
точки в 1 по индексу (Курьер), а после всегда выходить в любую указанную
выходную точку (от 2 до n) (Заказы).

Проблема данного решения в том, что он предполагает, что мы будем
использовать алгоритма Хельда-Капра n раз, где n = количеству заказов
для одного курьера, после будем сравнивать наилучший результат и уже
потом вернем найденный наилучший результат. Сложность по времени у
алгоритма $O(2^nn^2)$ с моей плохой реализацией будет $O(2^nn^2(n - 2))$,
так как n = 0 -> фиктивная точка, а n = 1 -> курьер, то конечных точек
будет всего n - 2.

```golang

func GenFakeDists(dists [][]float64, exit int) [][]float64 {
	n := len(dists)
	bigN := 10000000.0

	// Создаем матрицу с фиктивной точкой
	fakeDists := make([][]float64, n+1)
	for i := range fakeDists {
		fakeDists[i] = make([]float64, n+1)
	}

	// Определяем входную точку, а также
	// остальные поля заполняем "стеной"
	// в виде огромного числа
	for i := 0; i < n+1; i++ {
		if i == 1 {
			fakeDists[i][0] = 0
			continue
		}
		fakeDists[i][0] = bigN
	}

	// Определяем выходную точку
	for j := 0; j < n+1; j++ {
		if j == exit+1 {
			fakeDists[j][0] = 0
			continue
		}
		fakeDists[0][j] = bigN
	}

	// Копируем оригинал во внутрь
	// матрицы с фиктивной точкой
	for i := 1; i < n+1; i++ {
		for j := 1; j < n+1; j++ {
			fakeDists[i][j] = dists[i-1][j-1]
		}
	}

	return fakeDists
}

```
